

// THIS FILE IS AUTO-GENERATED BY FORGE. DO NOT EDIT.
import * as zod from './zod';
import * as sql from './sql';

class AuthorizationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'AuthorizationError';
    }
}


class UserDomain {
    deps = {};
    injectDependencies(dependencies) {
        this.deps = dependencies;
    }

    async create(ctx, data) {
        
        const validatedData = zod.CreateUserSchema.parse(data);
        let fullData = validatedData;

        

        
        
        const paramKeys = Object.keys(fullData);
        if(paramKeys.length === 0) {
           throw new Error("Cannot create a record with no data.");
        }
        const params = paramKeys.map(k => fullData[k]);
        const query = `INSERT INTO users (${paramKeys.map(toSnakeCase).join(', ')}) VALUES (${paramKeys.map((_, i) => `$${i + 1}`).join(', ')}) RETURNING *;`;

        const res = await ctx.db.query(query, params);
        const result = res.rows[0];
        ctx.audit.record('create', { model: 'User', id: result.id, userId: ctx.user.id, data: fullData });

        

        return zod.UserSchema.parse(result);
        
    }

    async findById(ctx, id) {
        const res = await ctx.db.query(sql.findUserById, [id]);
        if (res.rows.length === 0) {
            return null;
        }
        const result = zod.UserSchema.parse(res.rows[0]);
        
        return result;
    }

    async update(ctx, id, data) {
        
        let validatedData = zod.UpdateUserSchema.parse(data);
        if (Object.keys(validatedData).length === 0) {
            return this.findById(ctx, id);
        }
        const recordToUpdate = await this.findById(ctx, id); if (!recordToUpdate) { return null; }
        
        
        
        
        const query = sql.updateUser(validatedData);
        const params = [id, ...Object.values(validatedData)];

        const res = await ctx.db.query(query, params);
        if (res.rows.length === 0) {
            return null;
        }
        const result = zod.UserSchema.parse(res.rows[0]);
        ctx.audit.record('update', { model: 'User', id: result.id, userId: ctx.user.id, updates: validatedData });

        

        return result;
        
    }

    async delete(ctx, id) {
        
        const recordToDelete = await this.findById(ctx, id); if (!recordToDelete) { return false; }
        
        
        

        const res = await ctx.db.query(sql.deleteUser, [id]);
        if (res.rowCount > 0) {
            ctx.audit.record('delete', { model: 'User', id, userId: ctx.user.id });

            
            return true;
        }
        return false;
        
    }
    
    

    
}


class PostDomain {
    deps = {};
    injectDependencies(dependencies) {
        this.deps = dependencies;
    }

    async create(ctx, data) {
        
        const validatedData = zod.CreatePostSchema.parse(data);
        let fullData = validatedData;

        

        
        
        const paramKeys = Object.keys(fullData);
        if(paramKeys.length === 0) {
           throw new Error("Cannot create a record with no data.");
        }
        const params = paramKeys.map(k => fullData[k]);
        const query = `INSERT INTO posts (${paramKeys.map(toSnakeCase).join(', ')}) VALUES (${paramKeys.map((_, i) => `$${i + 1}`).join(', ')}) RETURNING *;`;

        const res = await ctx.db.query(query, params);
        const result = res.rows[0];
        ctx.audit.record('create', { model: 'Post', id: result.id, userId: ctx.user.id, data: fullData });

        

        return zod.PostSchema.parse(result);
        
    }

    async findById(ctx, id) {
        const res = await ctx.db.query(sql.findPostById, [id]);
        if (res.rows.length === 0) {
            return null;
        }
        const result = zod.PostSchema.parse(res.rows[0]);
        
        return result;
    }

    async update(ctx, id, data) {
        
        let validatedData = zod.UpdatePostSchema.parse(data);
        if (Object.keys(validatedData).length === 0) {
            return this.findById(ctx, id);
        }
        const recordToUpdate = await this.findById(ctx, id); if (!recordToUpdate) { return null; }
        
        
        
        
        const query = sql.updatePost(validatedData);
        const params = [id, ...Object.values(validatedData)];

        const res = await ctx.db.query(query, params);
        if (res.rows.length === 0) {
            return null;
        }
        const result = zod.PostSchema.parse(res.rows[0]);
        ctx.audit.record('update', { model: 'Post', id: result.id, userId: ctx.user.id, updates: validatedData });

        

        return result;
        
    }

    async delete(ctx, id) {
        
        const recordToDelete = await this.findById(ctx, id); if (!recordToDelete) { return false; }
        
        
        

        const res = await ctx.db.query(sql.deletePost, [id]);
        if (res.rowCount > 0) {
            ctx.audit.record('delete', { model: 'Post', id, userId: ctx.user.id });

            
            return true;
        }
        return false;
        
    }
    
    
    async findAuthorForPost(ctx, record) {
        if (!record.authorId) return null;
        // This automatically uses the target's findById, which includes its own read policies.
        return this.deps.userDomain.findById(ctx, record.authorId);
    }


    
}

const userDomain = new UserDomain();
const postDomain = new PostDomain();

// --- Dependency Injection for Relation Helpers ---
const allDomains = { userDomain, postDomain };
for (const domain of Object.values(allDomains)) {
    if (typeof domain.injectDependencies === 'function') {
        domain.injectDependencies(allDomains);
    }
}
    
