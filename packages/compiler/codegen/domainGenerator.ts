import { ModelDefinition, ForgeConfig, HookType } from '../ast/types.js';
import { GenerationResult } from '../ast/types.js';

function toPascalCase(str: string): string {
    return str.replace(/(?:^|-|_)(\w)/g, (_, c) => c.toUpperCase()).replace(/ /g, '');
}
function toCamelCase(str: string): string {
    const pascal = toPascalCase(str);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}
function toSnakeCase(str: string): string {
  return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`).replace(/^_/, '');
}

function renderPermissionGuard(modelName: string, action: 'create' | 'read' | 'update' | 'delete', permissions: any | undefined, recordRef: string): string {
    const rule = permissions?.[action];
    if (!rule) return '';

    const rolesArray = JSON.stringify(rule.roles ?? []);
    const claimsArray = JSON.stringify(rule.claims ?? []);
    const condition = rule.condition
        ? `((user, record) => ${rule.condition})(ctx.user, ${recordRef})`
        : 'true';

    return `
        {
            const requiredRoles = ${rolesArray};
            const requiredClaims = ${claimsArray};
            const userRoles = Array.isArray(ctx.user.roles) ? ctx.user.roles : (ctx.user.role ? [ctx.user.role] : []);
            const hasRole = requiredRoles.length ? userRoles.some(r => requiredRoles.includes(r)) : false;
            const userClaimKeys = ctx.user.claims ? Object.keys(ctx.user.claims) : [];
            const hasClaim = requiredClaims.length ? requiredClaims.some(claim => userClaimKeys.includes(claim) || Boolean(ctx.user.claims?.[claim])) : false;
            const baseAllowed = (requiredRoles.length || requiredClaims.length) ? (hasRole || hasClaim) : true;
            const conditionOk = ${condition};
            if (!(baseAllowed && conditionOk)) {
                throw new AuthorizationError('User does not have permission to ${action} ${modelName}');
            }
        }
    `;
}

export function generateDomainServices(models: ModelDefinition[], config: ForgeConfig): GenerationResult {
    const modelServices = models.map(m => `${toCamelCase(m.name)}Domain`).join(', ');
    const allModelPascalNames = models.map(m => toPascalCase(m.name));

const imports = `
// THIS FILE IS AUTO-GENERATED BY FORGE. DO NOT EDIT.
import * as zod from './zod';
import * as sql from './sql';
const traceSpan = (globalThis as any)?.traceSpan;
const runWithTrace = (name, attrs, fn) => (typeof traceSpan === 'function' ? traceSpan(name, attrs, fn) : fn());

class AuthorizationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'AuthorizationError';
    }
}
`;

    const services = models.map(model => {
        const namePascal = toPascalCase(model.name);
        const nameCamel = toCamelCase(model.name);
        
        const fields = Object.keys(model.schema);
        
        const tenantField = fields.find(f => {
            const opts = model.schema[f];
            // FIX: Check for null/undefined and filter out relations before accessing '.tenant'.
            return typeof opts === 'object' && opts && !(opts as any).__typeName && (opts as any).tenant;
        });

        const getHooks = (type: HookType) => model.hooks.filter(h => h.type === type);

        // --- FIND BY ID ---
        const findByIdParams = config.multiTenant && tenantField ? `[id, ctx.user.tenantId]` : `[id]`;
        const findByIdPolicy = model.policies.read;
        const findByIdGuard = findByIdPolicy
            ? `const canRead = (${findByIdPolicy.handlerSource}); if (result && !await canRead({ user: ctx.user, record: result })) { throw new AuthorizationError('User does not have permission to read this ${namePascal}'); }`
            : '';
        const findByIdPermissionGuard = renderPermissionGuard(model.name, 'read', model.permissions, 'result');

        // --- CREATE ---
        const createPolicy = model.policies.create;
        const createAudit = config.audit
            ? `ctx.audit.record('create', { model: '${namePascal}', id: result.id, userId: ctx.user.id, tenantId: ctx.user.tenantId, data: fullData });`
            : '';
        const createLogic = `
        const validatedData = zod.Create${namePascal}Schema.parse(data);
        let fullData = ${tenantField ? `{ ...validatedData, "${tenantField}": ctx.user.tenantId }` : 'validatedData' };

        ${renderPermissionGuard(model.name, 'create', model.permissions, 'fullData')}

        ${getHooks('beforeCreate').map((hook, i) => `
        const beforeCreateHook${i} = ${hook.handlerSource};
        const hookResult${i} = await beforeCreateHook${i}(fullData, ctx);
        if (hookResult${i}) { fullData = { ...fullData, ...hookResult${i} }; }
        `).join('')}

        ${createPolicy ? `const canCreate = (${createPolicy.handlerSource}); if (!await canCreate({ user: ctx.user, record: fullData })) { throw new AuthorizationError('User does not have permission to create ${namePascal}'); }` : ''}
        
        const paramKeys = Object.keys(fullData);
        if(paramKeys.length === 0) {
           throw new Error("Cannot create a record with no data.");
        }
        const params = paramKeys.map(k => fullData[k]);
        const query = \`INSERT INTO ${toSnakeCase(model.name)}s (\${paramKeys.map(toSnakeCase).join(', ')}) VALUES (\${paramKeys.map((_, i) => \`$\${i + 1}\`).join(', ')}) RETURNING *;\`;

        const res = await ctx.db.query(query, params);
        const result = res.rows[0];
        ${createAudit}

        ${getHooks('afterCreate').map((hook, i) => `
        const afterCreateHook${i} = ${hook.handlerSource};
        await afterCreateHook${i}(result, ctx);
        `).join('')}

        return zod.${namePascal}Schema.parse(result);
        `;

        // --- UPDATE ---
        const updatePolicy = model.policies.update;
        const updateGuardFetch = `const recordToUpdate = await this.findById(ctx, id); if (!recordToUpdate) { return null; }`;
        const updateGuardCheck = updatePolicy
            ? `const canUpdate = (${updatePolicy.handlerSource}); if (!await canUpdate({ user: ctx.user, record: recordToUpdate })) { throw new AuthorizationError('User does not have permission to update this ${namePascal}'); }`
            : '';
        const updateAudit = config.audit
            ? `ctx.audit.record('update', { model: '${namePascal}', id: result.id, userId: ctx.user.id, tenantId: ctx.user.tenantId, updates: validatedData });`
            : '';
        const updateParams = config.multiTenant && tenantField
            ? `[id, ...Object.values(validatedData), ctx.user.tenantId]`
            : `[id, ...Object.values(validatedData)]`;
        const updateLogic = `
        let validatedData = zod.Update${namePascal}Schema.parse(data);
        if (Object.keys(validatedData).length === 0) {
            return this.findById(ctx, id);
        }
        ${updateGuardFetch}
        ${renderPermissionGuard(model.name, 'update', model.permissions, 'recordToUpdate')}
        ${updateGuardCheck}
        
        ${getHooks('beforeUpdate').map((hook, i) => `
        const beforeUpdateHook${i} = ${hook.handlerSource};
        const hookResult${i} = await beforeUpdateHook${i}(validatedData, ctx);
        if (hookResult${i}) { validatedData = { ...validatedData, ...hookResult${i} }; }
        `).join('')}
        
        const query = sql.update${namePascal}(validatedData);
        const params = ${updateParams};

        const res = await ctx.db.query(query, params);
        if (res.rows.length === 0) {
            return null;
        }
        const result = zod.${namePascal}Schema.parse(res.rows[0]);
        ${updateAudit}

        ${getHooks('afterUpdate').map((hook, i) => `
        const afterUpdateHook${i} = ${hook.handlerSource};
        await afterUpdateHook${i}(result, ctx);
        `).join('')}

        return result;
        `;
        
        // --- DELETE ---
        const deletePolicy = model.policies.delete;
        const deleteGuardFetch = `const recordToDelete = await this.findById(ctx, id); if (!recordToDelete) { return false; }`;
        const deleteGuardCheck = deletePolicy
            ? `const canDelete = (${deletePolicy.handlerSource}); if (!await canDelete({ user: ctx.user, record: recordToDelete })) { throw new AuthorizationError('User does not have permission to delete this ${namePascal}'); }`
            : '';
        const deleteAudit = config.audit
            ? `ctx.audit.record('delete', { model: '${namePascal}', id, userId: ctx.user.id, tenantId: ctx.user.tenantId });`
            : '';
        const deleteParams = config.multiTenant && tenantField ? `[id, ctx.user.tenantId]` : `[id]`;
        const deleteLogic = `
        ${deleteGuardFetch}
        ${renderPermissionGuard(model.name, 'delete', model.permissions, 'recordToDelete')}
        ${deleteGuardCheck}
        
        ${getHooks('beforeDelete').map((hook, i) => `
        const beforeDeleteHook${i} = ${hook.handlerSource};
        await beforeDeleteHook${i}(recordToDelete, ctx);
        `).join('')}

        const res = await ctx.db.query(sql.delete${namePascal}, ${deleteParams});
        if (res.rowCount > 0) {
            ${deleteAudit}

            ${getHooks('afterDelete').map((hook, i) => `
            const afterDeleteHook${i} = ${hook.handlerSource};
            await afterDeleteHook${i}({ id }, ctx);
            `).join('')}
            return true;
        }
        return false;
        `;

        // --- RELATIONS ---
        const relationMethods = model.relations.map(rel => {
            const targetModel = models.find(m => m.name === rel.targetModelName);
            if (!targetModel) {
                 // Fail fast with a clear error if a relation points to a non-existent model.
                throw new Error(`Invalid relation in model "${model.name}": The relation "${rel.name}" points to a non-existent model named "${rel.targetModelName}".`);
            }

            const targetPascal = toPascalCase(rel.targetModelName);
            const targetCamel = toCamelCase(rel.targetModelName);
            const targetDomain = `${targetCamel}Domain`;
            
            if (rel.type === 'belongsTo') {
                const fk = rel.foreignKey;
                const methodName = `find${toPascalCase(rel.name)}For${namePascal}`;
                return `
    async ${methodName}(ctx, record) {
        if (!record.${fk}) return null;
        // This automatically uses the target's findById, which includes its own read policies.
        return this.deps.${targetDomain}.findById(ctx, record.${fk});
    }
`;
            } else if (rel.type === 'hasMany') {
                const queryName = `find${targetPascal}sBy${namePascal}Id`;
                const methodName = `find${toPascalCase(rel.name)}For${namePascal}`;
                const targetReadPolicy = targetModel.policies.read;
                
                const policyCheck = targetReadPolicy
                    ? `
        const canRead = (${targetReadPolicy.handlerSource});
        const allowedResults = [];
        for(const item of results) {
            if (await canRead({ user: ctx.user, record: item })) {
                allowedResults.push(item);
            }
        }
        return allowedResults;`
                    : `return results;`;

                return `
    async ${methodName}(ctx, record) {
        const res = await ctx.db.query(sql.${queryName}, [record.id]);
        const results = res.rows.map(row => zod.${targetPascal}Schema.parse(row));
        ${policyCheck}
    }
`;
            }
            return '';
        }).join('\n');
        
        // --- EXTENSIONS ---
        const extensions = model.extensions.map(ext => `
    ${ext.handlerSource}
        `).join('\n');


        return `
class ${namePascal}Domain {
    deps = {};
    injectDependencies(dependencies) {
        this.deps = dependencies;
    }

    async create(ctx, data) {
        return runWithTrace('service.${namePascal}.create', { model: '${namePascal}', action: 'create', userId: ctx.user?.id }, async () => {
        ${createLogic}
        });
    }

    async findById(ctx, id) {
        return runWithTrace('service.${namePascal}.read', { model: '${namePascal}', action: 'read', userId: ctx.user?.id }, async () => {
            const res = await ctx.db.query(sql.find${namePascal}ById, ${findByIdParams});
            if (res.rows.length === 0) {
                return null;
            }
            const result = zod.${namePascal}Schema.parse(res.rows[0]);
            ${findByIdPermissionGuard}
            ${findByIdGuard}
            return result;
        });
    }

    async update(ctx, id, data) {
        return runWithTrace('service.${namePascal}.update', { model: '${namePascal}', action: 'update', userId: ctx.user?.id }, async () => {
        ${updateLogic}
        });
    }

    async delete(ctx, id) {
        return runWithTrace('service.${namePascal}.delete', { model: '${namePascal}', action: 'delete', userId: ctx.user?.id }, async () => {
        ${deleteLogic}
        });
    }
    
    ${relationMethods}

    ${extensions}
}
`;
    }).join('\n');

    const exports = models.map(model => {
        const nameCamel = toCamelCase(model.name);
        const namePascal = toPascalCase(model.name);
        return `const ${nameCamel}Domain = new ${namePascal}Domain();`;
    }).join('\n');

    const dependencyInjection = `
// --- Dependency Injection for Relation Helpers ---
const allDomains = { ${models.map(m => `${toCamelCase(m.name)}Domain`).join(', ')} };
for (const domain of Object.values(allDomains)) {
    if (typeof domain.injectDependencies === 'function') {
        domain.injectDependencies(allDomains);
    }
}
    `;


    const content = `
${imports}
${services}
${exports}
${dependencyInjection}
`;

    return {
        filePath: 'domain.ts',
        content,
    };
}
